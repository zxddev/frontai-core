# 基于EmergencyAI的单事件救援实现方案

> **创建时间**: 2025-12-02  
> **方案背景**: 暂时使用EmergencyAI处理单事件救援，避开FrontlineRescueAgent配置依赖问题  
> **实施状态**: 设计完成，待前端集成

---

## 🎯 方案概述

### 核心思路
由于FrontlineRescueAgent存在`FRONTLINE_ALLOCATION_CONSTRAINTS_V1`配置依赖问题导致"暂无可用队伍"，我们临时采用EmergencyAI来实现单事件救援功能。

### 技术选择理由
1. **EmergencyAI质量优秀**: 1734行核心算法，专业级实现
2. **API已经完善**: 现有的分析和确认接口
3. **避免配置问题**: 不依赖缺失的FRONTLINE配置
4. **快速上线**: 最小化前端改动

---

## 🛠️ 实现架构

### 整体流程
```mermaid
graph TD
    A[用户点击救援方案] --> B[前端Modal]
    B --> C{检查缓存}
    C -->|有缓存| D[直接显示结果]
    C -->|无缓存| E[调用EmergencyAI]
    E --> F[启动分析任务]
    F --> G[轮询任务状态]
    G -->|进行中| H[显示"分析中..."]
    G -->|完成| I[展示救援方案]
    I --> J[用户确认部署]
    J --> K[调用确认接口]
    K --> L[部署成功/冲突提示]
```

### API端点设计
```typescript
interface EmergencyRescueAPI {
  // 1. 启动分析任务
  analyze: POST /api/v2/ai/emergency-analyze
  
  // 2. 查询任务状态  
  status: GET /api/v2/ai/emergency-analyze/{task_id}
  
  // 3. 确认部署方案
  confirm: POST /api/v2/ai/emergency-analyze/{task_id}/confirm
}
```

---

## 💻 前端实现方案

### 1. Hook设计 (优化版useEmergencyAnalyze)

```typescript
// src/hooks/useEmergencyAnalyze.js
import { useState, useEffect, useCallback } from 'react';
import { request } from '../utils/request';

export const useEmergencyAnalyze = () => {
  const [state, setState] = useState({
    isAnalyzing: false,
    taskId: null,
    result: null,
    error: null,
    progress: 'idle' // idle | analyzing | completed | failed
  });

  /**
   * 启动救援分析
   */
  const startAnalysis = useCallback(async (eventData) => {
    setState(prev => ({
      ...prev,
      isAnalyzing: true,
      error: null,
      progress: 'analyzing'
    }));

    try {
      const response = await request.post('/api/v2/ai/emergency-analyze', {
        event_location: {
          latitude: eventData.latitude,
          longitude: eventData.longitude
        },
        disaster_description: eventData.description,
        scenario_id: eventData.scenarioId,
        disaster_type: eventData.type || 'earthquake',
        estimated_victims: eventData.estimatedVictims || 0
      });

      if (response.success && response.task_id) {
        setState(prev => ({
          ...prev,
          taskId: response.task_id
        }));
        
        // 启动轮询
        startPolling(response.task_id);
      } else {
        throw new Error(response.message || '启动分析失败');
      }
    } catch (error) {
      setState(prev => ({
        ...prev,
        isAnalyzing: false,
        error: error.message,
        progress: 'failed'
      }));
    }
  }, []);

  /**
   * 轮询任务状态
   */
  const startPolling = useCallback((taskId) => {
    const pollInterval = setInterval(async () => {
      try {
        const response = await request.get(
          `/api/v2/ai/emergency-analyze/${taskId}`,
          { silent: true }
        );

        if (response.status === 'completed') {
          clearInterval(pollInterval);
          setState(prev => ({
            ...prev,
            isAnalyzing: false,
            result: response.result,
            progress: 'completed'
          }));
        } else if (response.status === 'failed') {
          clearInterval(pollInterval);
          setState(prev => ({
            ...prev,
            isAnalyzing: false,
            error: response.error || '分析失败',
            progress: 'failed'
          }));
        }
        // status === 'processing' 时继续轮询
      } catch (error) {
        // 静默处理网络错误，继续轮询
        console.warn('轮询出错:', error);
      }
    }, 2000);

    // 设置最大轮询时间（5分钟）
    setTimeout(() => {
      clearInterval(pollInterval);
      setState(prev => {
        if (prev.progress === 'analyzing') {
          return {
            ...prev,
            isAnalyzing: false,
            error: '分析超时，请重试',
            progress: 'failed'
          };
        }
        return prev;
      });
    }, 5 * 60 * 1000);
  }, []);

  /**
   * 确认部署方案
   */
  const confirmDeployment = useCallback(async (teamIds) => {
    if (!state.taskId) {
      throw new Error('无有效任务ID');
    }

    try {
      const response = await request.post(
        `/api/v2/ai/emergency-analyze/${state.taskId}/confirm`,
        { team_ids: teamIds }
      );

      return response;
    } catch (error) {
      throw error;
    }
  }, [state.taskId]);

  return {
    ...state,
    startAnalysis,
    confirmDeployment
  };
};
```

### 2. Modal组件集成

```jsx
// src/view/modal/rescue-action-modal.jsx (关键修改)
import { useEmergencyAnalyze } from '../../hooks/useEmergencyAnalyze';

export const RescueActionModal = ({ rescuePoint, onClose }) => {
  const {
    isAnalyzing,
    result,
    error,
    progress,
    startAnalysis,
    confirmDeployment
  } = useEmergencyAnalyze();

  // 组件挂载时自动启动分析
  useEffect(() => {
    if (rescuePoint && !result && progress === 'idle') {
      startAnalysis({
        latitude: rescuePoint.latitude,
        longitude: rescuePoint.longitude,
        description: rescuePoint.description,
        scenarioId: rescuePoint.scenarioId,
        type: rescuePoint.type,
        estimatedVictims: rescuePoint.estimatedVictims
      });
    }
  }, [rescuePoint, result, progress, startAnalysis]);

  // 确认部署处理
  const handleConfirmDeployment = async () => {
    if (!result?.recommended_teams) return;
    
    try {
      const teamIds = result.recommended_teams.map(team => team.team_id);
      const confirmResult = await confirmDeployment(teamIds);
      
      if (confirmResult.success) {
        message.success(`成功部署${teamIds.length}支队伍`);
        onClose();
      } else if (confirmResult.conflicts) {
        // 处理冲突情况
        Modal.confirm({
          title: '资源冲突提示',
          content: `以下队伍已被分配：${confirmResult.conflicts.map(c => c.team_name).join('、')}`,
          onOk: () => {
            // 重新分析或手动调整
          }
        });
      }
    } catch (error) {
      message.error(error.message);
    }
  };

  return (
    <Modal
      title="一线救援行动方案"
      visible={true}
      onCancel={onClose}
      width={800}
      footer={null}
    >
      {/* 进度显示 */}
      {progress === 'analyzing' && (
        <div className="text-center py-8">
          <Spin size="large" />
          <div className="mt-4">正在分析救援方案...</div>
          <Progress 
            type="line" 
            percent={isAnalyzing ? undefined : 100}
            showInfo={false}
            className="mt-2"
          />
        </div>
      )}

      {/* 错误显示 */}
      {error && (
        <Alert
          type="error"
          message="分析失败"
          description={error}
          showIcon
          action={
            <Button size="small" onClick={() => startAnalysis(rescuePoint)}>
              重试
            </Button>
          }
        />
      )}

      {/* 结果显示 */}
      {result && progress === 'completed' && (
        <div>
          <div className="mb-4">
            <Tag color="blue">推荐方案</Tag>
            <span className="ml-2">预计{result.recommended_teams?.length || 0}支队伍参与救援</span>
          </div>

          {/* 队伍列表 */}
          <Table
            dataSource={result.recommended_teams || []}
            columns={[
              { title: '队伍名称', dataIndex: 'team_name', key: 'name' },
              { title: '类型', dataIndex: 'resource_type', key: 'type' },
              { title: '距离', dataIndex: 'distance_km', key: 'distance', render: (d) => `${d}km` },
              { title: 'ETA', dataIndex: 'eta_minutes', key: 'eta', render: (m) => `${m}分钟` },
              { title: '救援能力', dataIndex: 'rescue_capacity', key: 'capacity', render: (c) => `${c}人` }
            ]}
            pagination={false}
            size="small"
          />

          {/* 行动按钮 */}
          <div className="flex justify-end space-x-2 mt-4">
            <Button onClick={onClose}>取消</Button>
            <Button 
              type="primary" 
              onClick={handleConfirmDeployment}
              disabled={!result?.recommended_teams?.length}
            >
              确认部署 ({result?.recommended_teams?.length || 0}支队伍)
            </Button>
          </div>
        </div>
      )}
    </Modal>
  );
};
```

### 3. 缓存机制

```typescript
// src/utils/emergencyCache.js
class EmergencyAnalysisCache {
  private cache = new Map();
  private readonly TTL = 5 * 60 * 1000; // 5分钟过期

  /**
   * 生成缓存键
   */
  private generateKey(eventData) {
    return `${eventData.latitude}_${eventData.longitude}_${eventData.type}_${eventData.estimatedVictims}`;
  }

  /**
   * 获取缓存结果
   */
  get(eventData) {
    const key = this.generateKey(eventData);
    const cached = this.cache.get(key);
    
    if (!cached) return null;
    
    // 检查是否过期
    if (Date.now() - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }

  /**
   * 设置缓存
   */
  set(eventData, result) {
    const key = this.generateKey(eventData);
    this.cache.set(key, {
      data: result,
      timestamp: Date.now()
    });
  }

  /**
   * 清除过期缓存
   */
  cleanup() {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.TTL) {
        this.cache.delete(key);
      }
    }
  }
}

export const emergencyCache = new EmergencyAnalysisCache();

// 定期清理
setInterval(() => emergencyCache.cleanup(), 60000);
```

---

## 🔌 后端API接口

### 现有接口状态

#### ✅ 已实现并测试通过
```python
# 1. 启动分析任务
POST /api/v2/ai/emergency-analyze
# 测试结果: ✅ 成功 (task_id: emergency-550e8400-e29b-41d4-a716-446655440000)

# 2. 查询任务状态
GET /api/v2/ai/emergency-analyze/{task_id}  
# 测试结果: ✅ 成功 (找到2支队伍：蓝天救援队茂县分队 + 华西医院应急医疗队)

# 3. 确认部署
POST /api/v2/ai/emergency-analyze/{task_id}/confirm
# 测试结果: ✅ 成功 (部署2支队伍) + ✅ 冲突检测正常
```

#### 📋 接口详细参数

```python
# src/agents/router.py:525-665 confirm_emergency_scheme()
@router.post("/emergency-analyze/{task_id}/confirm")
async def confirm_emergency_scheme(
    task_id: str,
    request: Dict[str, Any]  # {"team_ids": ["uuid1", "uuid2", ...]}
) -> Dict[str, Any]:
    """
    确认EmergencyAI推荐的救援方案
    
    Returns:
        成功: {"success": True, "deployed_teams": [...]}
        冲突: {"success": False, "conflicts": [...], "available_teams": [...]}
    """
```

### 无需修改
当前API已经满足单事件救援需求，无需额外开发。

---

## 📱 用户体验设计

### 交互流程
1. **立即响应**: 用户点击后立即显示"正在分析..."
2. **进度提示**: 清晰的加载状态和预期时间  
3. **实时更新**: 2秒轮询间隔，及时显示结果
4. **错误恢复**: 网络错误自动重试，超时提示重新分析
5. **冲突处理**: 资源冲突时提供清晰的解决选项

### 状态消息设计
```typescript
const StatusMessages = {
  analyzing: "正在分析救援方案...",
  processing: "AI正在计算最优资源配置...", 
  completed: "分析完成，发现可用救援队伍",
  failed: "分析失败，请检查网络连接后重试",
  timeout: "分析超时，可能是复杂事件，请重试",
  conflict: "部分队伍已被占用，请选择其他方案"
};
```

---

## 🚀 实施步骤

### Phase 1: 核心功能 (立即实施)
- [x] API接口已完成并测试  
- [ ] 修改RescueActionModal集成EmergencyAI
- [ ] 实现useEmergencyAnalyze Hook
- [ ] 添加进度提示和错误处理

### Phase 2: 优化体验 (1周内)
- [ ] 添加结果缓存机制
- [ ] 优化加载状态展示
- [ ] 完善冲突处理流程
- [ ] 添加重试和取消功能

### Phase 3: 功能增强 (2周内)  
- [ ] 添加历史分析记录
- [ ] 支持方案对比功能
- [ ] 集成地图可视化
- [ ] 性能监控和日志

---

## 📊 预期效果

### 解决的问题
1. ✅ **"暂无可用队伍"问题**: 绕过FrontlineRescueAgent的配置依赖
2. ✅ **救援方案生成**: 使用专业级EmergencyAI算法
3. ✅ **资源冲突检测**: 已实现的确认接口提供冲突检测

### 性能指标
- **响应时间**: < 3秒启动分析
- **分析时间**: 通常30-60秒完成
- **准确率**: 基于EmergencyAI的专业算法
- **冲突检测**: 实时验证资源可用性

### 用户体验提升
- 即时响应，清晰进度提示
- 专业的救援方案推荐  
- 智能的冲突处理机制
- 友好的错误恢复流程

---

## ⚠️ 注意事项

### 1. 临时方案限制
- 仅支持单事件救援，不支持多事件全局优化
- 不能完全替代FrontlineRescueAgent的全部功能

### 2. 性能考虑  
- EmergencyAI分析相对较慢（30-60秒）
- 需要合理的缓存策略避免重复分析
- 轮询频率需要平衡实时性和服务器压力

### 3. 错误边界
- 网络异常的处理和重试机制
- 分析超时的用户提示和恢复
- API异常时的降级策略

---

## 🔗 相关文档

- [智能体架构分析.md](./智能体架构分析.md) - EmergencyAI vs FrontlineRescueAgent详细对比
- [当前问题与解决状态.md](./当前问题与解决状态.md) - 问题跟踪和解决进展
- [FrontlineRescueAgent优化路线图.md](./FrontlineRescueAgent优化路线图.md) - 长期优化计划

---

*本方案为临时解决方案，长期目标仍是完善FrontlineRescueAgent的多事件全局调度能力。*
