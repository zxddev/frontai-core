# 调用规范

本文档定义项目中各层之间的调用规范，确保代码结构清晰、可维护、可测试。

## 1. 架构层次

```
┌─────────────────────────────────────────────────────────┐
│                    入口层（Adapters）                    │
│   frontend_api/   │   agents/router   │   domains/router │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│              应用服务层（Service）                        │
│   domains/*/service.py                                  │
│   - 编排业务流程                                         │
│   - 管理事务边界                                         │
│   - 实例化 Repository 和 Core                           │
└─────────────────────────────────────────────────────────┘
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────────┐
│  Core（核心）  │  │  Repository   │  │  External Client  │
│  纯业务逻辑    │  │  数据访问接口  │  │  外部服务客户端    │
│  无 IO 依赖    │  │               │  │                   │
└───────────────┘  └───────────────┘  └───────────────────┘
          │
          ▼
┌───────────────────────┐
│    Algorithm（算法）   │
│  planning/algorithms  │
│  纯函数，无状态        │
└───────────────────────┘
```

---

## 2. 核心原则

### 原则一：依赖方向单向向下

```
入口层 → Service → Core → Algorithm
                 → Repository
                 → External Client
```

**禁止反向依赖：**
- ❌ Core 不能调用 Service
- ❌ Repository 不能调用 Service
- ❌ Algorithm 不能调用任何上层

### 原则二：Core 层纯净

Core 层是纯业务逻辑，**不能**持有：
- ❌ 数据库会话（db/session）
- ❌ HTTP 客户端
- ❌ 配置对象

Core 层**只能**接收：
- ✅ Repository 接口（用于数据访问）
- ✅ 领域实体/值对象（纯数据）
- ✅ 配置值（而非配置对象）

### 原则三：Service 层负责编排

Service 层的职责：
- 实例化 Repository 和 Core
- 管理事务边界
- 编排多个 Core 的协作
- 参数校验和错误处理
- 日志记录

---

## 3. 正确的调用示例

### Service 层

```python
# src/domains/resource_scheduling/service.py
from sqlalchemy.ext.asyncio import AsyncSession

from .core import ResourceSchedulingCore
from .repository import ResourceSchedulingRepository
from .schemas import ScheduleRequest, ScheduleResponse


class ResourceSchedulingService:
    """资源调度服务 - 可实例化，支持依赖注入"""
    
    def __init__(self, db: AsyncSession):
        self._db = db
        self._repo = ResourceSchedulingRepository(db)
    
    async def schedule(self, request: ScheduleRequest) -> ScheduleResponse:
        """执行资源调度"""
        # Service 实例化 Core，传入 Repository
        core = ResourceSchedulingCore(self._repo)
        
        # 调用 Core 的业务逻辑
        result = await core.schedule(
            destination=request.destination,
            requirements=request.requirements,
        )
        
        return ScheduleResponse.from_domain(result)
```

### Core 层

```python
# src/domains/resource_scheduling/core.py
from .repository import ResourceSchedulingRepository
from src.planning.algorithms.routing import DatabaseRouteEngine


class ResourceSchedulingCore:
    """资源调度核心逻辑 - 纯业务，无 IO"""
    
    def __init__(self, repo: ResourceSchedulingRepository):
        self._repo = repo  # 接收 Repository，不是 db
    
    async def schedule(self, destination, requirements):
        # 通过 Repository 获取数据
        candidates = await self._repo.find_available_resources(requirements)
        
        # 调用纯算法
        # 注意：耗时算法需要异步处理（见 Section 7）
        routes = await self._calculate_routes(candidates, destination)
        
        # 纯业务逻辑处理
        return self._select_best_solution(candidates, routes)
```

### Repository 层

```python
# src/domains/resource_scheduling/repository.py
from sqlalchemy.ext.asyncio import AsyncSession


class ResourceSchedulingRepository:
    """数据访问层 - 封装所有数据库操作"""
    
    def __init__(self, db: AsyncSession):
        self._db = db
    
    async def find_available_resources(self, requirements):
        """查询可用资源"""
        query = select(Resource).where(Resource.status == 'available')
        result = await self._db.execute(query)
        return result.scalars().all()
```

---

## 4. 入口层调用规范

### HTTP Router → Service

```python
# src/domains/resource_scheduling/router.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.database import get_db
from .service import ResourceSchedulingService
from .schemas import ScheduleRequest, ScheduleResponse

router = APIRouter()


@router.post("/schedule", response_model=ScheduleResponse)
async def schedule(
    request: ScheduleRequest,
    db: AsyncSession = Depends(get_db),  # 依赖注入
):
    service = ResourceSchedulingService(db)
    return await service.schedule(request)
```

### Agent Node → Service

```python
# src/agents/emergency_ai/nodes/matching.py
from pydantic import ValidationError

from src.domains.resource_scheduling.service import ResourceSchedulingService
from src.domains.resource_scheduling.schemas import ScheduleRequest


async def matching_node(state: EmergencyAIState, db: AsyncSession) -> dict:
    """Agent 节点调用 Service"""
    
    # ⚠️ 必须：使用 Pydantic 校验 LLM 输出
    try:
        request = ScheduleRequest(
            destination=state.parsed_location,
            requirements=state.capability_requirements,
        )
    except ValidationError as e:
        return {"error": f"数据校验失败: {e}"}
    
    # 调用 Service
    service = ResourceSchedulingService(db)
    result = await service.schedule(request)
    
    return {"scheduling_result": result}
```

---

## 5. 禁止的调用方式

### ❌ Core 调用 Service（循环依赖）

```python
# ❌ 绝对禁止
# src/domains/staging_area/core.py
from src.domains.resource_scheduling.service import ResourceSchedulingService  # 循环依赖！

class StagingAreaCore:
    async def do_something(self):
        service = ResourceSchedulingService(self._db)  # 错误！
```

**正确做法**：跨域协作在 Service 层编排

```python
# ✅ 正确：Service 层编排多个 Core
# src/domains/staging_area/service.py
from .core import StagingAreaCore
from src.domains.resource_scheduling.core import ResourceSchedulingCore

class StagingAreaService:
    def __init__(self, db: AsyncSession):
        self._staging_repo = StagingAreaRepository(db)
        self._scheduling_repo = ResourceSchedulingRepository(db)
    
    async def recommend_with_scheduling(self, request):
        # Service 编排多个 Core
        staging_core = StagingAreaCore(self._staging_repo)
        scheduling_core = ResourceSchedulingCore(self._scheduling_repo)
        
        staging_result = await staging_core.recommend(...)
        scheduling_result = await scheduling_core.schedule(...)
        
        return self._merge_results(staging_result, scheduling_result)
```

### ❌ Core 持有数据库会话

```python
# ❌ 错误
class StagingAreaCore:
    def __init__(self, db: AsyncSession):  # 不应该接收 db
        self._db = db
```

### ❌ Service 使用 @staticmethod

```python
# ❌ 错误：无法 Mock，无法依赖注入
class StagingAreaService:
    @staticmethod
    async def recommend(request, db=None):  # 静态方法 + db=None
        ...
```

### ❌ Agent 未校验数据直接调用 Service

```python
# ❌ 错误：LLM 输出可能有幻觉
async def matching_node(state):
    service = ResourceSchedulingService(db)
    result = await service.schedule(
        destination=state.raw_llm_output["location"],  # 未校验！
    )
```

---

## 6. 事务管理

### 原则：事务边界在 Service 层

```python
# src/domains/resource_scheduling/service.py
class ResourceSchedulingService:
    def __init__(self, db: AsyncSession):
        self._db = db
    
    async def schedule_with_transaction(self, request):
        """带事务的调度"""
        async with self._db.begin():  # 事务开始
            result = await self._do_schedule(request)
            await self._repo.save(result)
            # 事务自动提交或回滚
        return result
```

### 跨 Service 调用时传递同一个 db

```python
# ✅ 正确：保证事务一致性
async def complex_operation(db: AsyncSession):
    async with db.begin():
        service_a = ServiceA(db)  # 同一个 db
        service_b = ServiceB(db)  # 同一个 db
        
        await service_a.do_something()
        await service_b.do_something()
        # 两个操作在同一个事务中
```

---

## 7. 异步与性能

### 耗时算法必须异步执行

```python
# src/domains/resource_scheduling/core.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

# 创建线程池（模块级别）
_executor = ThreadPoolExecutor(max_workers=4)


class ResourceSchedulingCore:
    async def _calculate_routes(self, candidates, destination):
        """耗时算法使用线程池执行，避免阻塞 event loop"""
        loop = asyncio.get_event_loop()
        
        # 在线程池中运行同步算法
        result = await loop.run_in_executor(
            _executor,
            self._sync_route_calculation,  # 同步函数
            candidates,
            destination,
        )
        return result
    
    def _sync_route_calculation(self, candidates, destination):
        """同步的路径计算（CPU 密集型）"""
        # 这里调用纯算法
        from src.planning.algorithms.routing import some_algorithm
        return some_algorithm(candidates, destination)
```

### 判断是否需要异步执行

| 操作类型 | 耗时 | 处理方式 |
|---------|------|---------|
| 数据库查询 | < 50ms | 直接 await（已经是异步） |
| 路径规划 | > 100ms | `run_in_executor` |
| 优化算法 | > 500ms | `run_in_executor` |
| LLM 调用 | > 1s | 使用异步客户端 |

---

## 8. 各层职责总结

| 层 | 文件 | 职责 | 可依赖 |
|----|------|------|--------|
| **入口层** | `router.py`, `nodes/*.py` | 接收请求，调用 Service | Service |
| **Service** | `service.py` | 编排、事务、校验、日志 | Core, Repository, External Client |
| **Core** | `core.py` | 纯业务逻辑 | Repository（接口）, Algorithm |
| **Repository** | `repository.py` | 数据访问 | 数据库 |
| **Algorithm** | `planning/algorithms/` | 纯算法 | 无 |

---

## 9. 迁移指南

### 现有代码问题清单

以下是现有代码中需要修复的问题：

| 文件 | 问题 | 优先级 |
|------|------|--------|
| `domains/*/service.py` | 使用 `@staticmethod` | 中 |
| `domains/*/service.py` | 方法签名 `db=None` | 高 |
| `domains/*/core.py` | 构造函数接收 `db` | 高 |
| `agents/*/nodes/*.py` | 直接调用 Core | 中 |
| `agents/*/nodes/*.py` | 未校验 LLM 输出 | 高 |

### 渐进式迁移原则

1. **新代码必须遵循本规范**
2. **修改旧代码时顺便迁移**
3. **高优先级问题优先修复**
4. **不主动大规模重构工作正常的代码**

### 迁移示例

```python
# 迁移前
class StagingAreaService:
    @staticmethod
    async def recommend(request, db=None):
        if db is None:
            db = AsyncSessionLocal()
        core = StagingAreaCore(db)
        return await core.recommend(...)

# 迁移后
class StagingAreaService:
    def __init__(self, db: AsyncSession):
        self._repo = StagingAreaRepository(db)
    
    async def recommend(self, request: RecommendRequest) -> RecommendResponse:
        core = StagingAreaCore(self._repo)
        return await core.recommend(...)
```
